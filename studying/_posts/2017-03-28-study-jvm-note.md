---
title: JVM学习笔记
date: 2017-03-28 19:25:03 +0800
tags: JVM, 笔记
---

这个笔记是学习《深入理解Java虚拟机：JVM高级特性与最佳实践（第二版）》的过程中记录下的。

---

# 第二章 Java内存区域与内存溢出异常

-----

## 2.2 运行时数据区域

Java虚拟机所管理的内容包括以下几个运行时数据区域：

![Java内存区域划分](/assets/pictures/studying/java_runtime_memory_area.PNG)

- **程序计数器**：线程私有，记录当前线程执行到的字节码的行号（准确来说应该是偏移地址）。当执行本地Native方法时为空
- **Java虚拟机栈**：线程私有。描述Java方法执行的内存模型。每个方法都会有一个栈帧，存储着局部变量表、操作数栈、动态链接、方法出口等信息。
- - 局部变量表存储着编译期可知的基本数据类型、对象引用和returnAddress类型。
- **本地方法栈**
- **Java堆**：线程共享，存放几乎所有的对象实例，也是垃圾管理器的管理区域。可细分为新生代（Young Gen）和老年代（Old Gen），具体看垃圾回收部分。
- **方法区**：线程共享，存储被虚拟机加载的类信息，常量，静态变量，即时编译器（JIT）编译后的代码等数据，也叫“永久代”（Perm Gen）。
- **运行时常量池**：方法区一部分，存放着Class文件中的符号引用，以及加载解析出来的直接引用。
- **直接内存**：Native方法使用的内存，JDK1.4加入的nio包也用这块内存。

-----

## 2.3 HotSpot虚拟机对象探秘

### 对象的创建

遇到一条new指令时，首先检查能否在常量池中定位到一个类的符号引用，并且检查这个类是否已被加载、解析和初始化过，如果没有，则执行加载类加载过程。类加载检查通过后，虚拟机将为接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定（如何确定将在2.3.2节中介绍），为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。
- 分配的方式主要有两种：
- - 指针碰撞：若内存规整，用过的内存都在一边的话，只需要移动指针位置即可。
- - 空闲列表：虚拟机维护一个空闲内存的列表，需要分配内存时，在列表中找到足够大的空间给对象实例。
- 并发情况下，每个线程在Java堆中预先分配一小块内存，成为本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）。线程先在自己的TLAB上分配，若空间不够再同步锁定，获取新的TLAB空间。

然后，虚拟机设置对象的对象头（Object Header）信息，包括对象属于哪个类，如何找到类的元数据，对象的哈希码，GC分代年龄信息等。

然而此时还没有调用对象的\<init\>方法。

### 对象的内存布局

对象在内存中的布局分为三个区域：
- **对象头**：一部分是存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。另一部分是类型指针，指向类型元数据的指针。
- **实例数据**：代码中定义的各类型字段的内容
- **对齐填充**：占位符。HotSpot虚拟机中要求对象起始地址必须是8位数的整数倍

### 对象的访问定位

主流的访问方式有两种：
- 句柄访问：内存中有句柄池，reference类型储存的是句柄地址，通过句柄来获取对象实例数据和类型数据。
- 直接指针访问：堆中放对象实例数据，通过实例数据储存的类型数据指针访问类型数据。

HotSpot虚拟机使用直接指针访问方式。

### 各个内存区域内存溢出

- 虚拟机栈和本地方法栈：单线程中，栈帧太大或栈容量太小，无法分配内存的时候会抛出StackOverFlowError。多线程中，若线程太多，线程栈占用空间太大，无法获取空间给新的线程创建栈的时候，会抛出OutOfMemoryError。
- 方法区和运行时常量池：类产生太多，动态产生类导致方法区被填满时抛出OutOfMemoryError。
- 本机直接内存溢出

---

# 第三章 垃圾收集器与内存分配策略

## 3.2 判断对象存活与否的算法

下面的算法是确定对象哪些存活，哪些死去

### 引用计数算法

**过程**：给对象添加一个引用计数器，每当有一个地方引用时，给计数器加1；引用失效时，计数器见1。当计数器的值为0时，对象是不可能再被使用了。

不能解决对象之间的循环引用问题，也就是当两个对象互相拥有对方的引用的时候，导致引用计数器不为0。

### 可达性分析算法

**过程**：通过一系列成为“GC Roots”的对象作为起始点，从这些节点开始乡下搜索，搜索时走过的路径称为**引用链**（Reference Chain），当一个对象没有任何引用链相连，也就是从GC Roots到这个对象不可达时，则这个对象是不可用的。

Java中，可以做GC Roots的对象有：
- 虚拟机栈（栈帧中的本地变量表）中引用的对象。
- 方法区中类静态属性引用的对象。
- 方法区中常量引用的对象。

### 再谈引用

Java引用分为如下几种：
- **强引用**：直接声明使用的对象的引用。
- **软引用**：描述有用但是并非必须的对象。在内存溢出之前，回收这些软引用的对象。
- **弱引用**：同时非必须对象，但是比软引用更弱。会在下一次垃圾回收过程中被回收。
- **虚引用**：最弱的引用关系，不会对对象生存时间构成影响，无法获得这个对象实例。唯一目的是在被回收前获得一个系统通知。

### 判断对象死亡

1. 对象在可达性分析后，发现没有与GC Roots相连的引用链，对象第一次被标记并进行筛选。筛选的过程是判断有没有必要执行`finalize()`方法。若没有覆盖这个方法，或者已被调用过，则没有必要执行，对象已死。
2. 通过筛选的对象，会被放在叫做`F-Queue`的队列之中，并稍后会由一个由虚拟机建立的低优先级的Finalizer线程去执行对象的`finalize()`方法。注意，虚拟机会触发这个方法，但是**不会等待它运行结束**。之后，GC会对`F-Queue`中的对象进行第二次小规模的标记，若对象的`finalize()`方法让其重新与引用链上的任何一个对象建立了关联，则对象存活。否则死亡。

*`finalize()`方法不是C++的析构方法，不能保证会运行，尽量避免使用*

### 回收方法区

垃圾回收主要收集**废弃常量**和**无用的类**。

无用类的判定条件：
- 该类的所有实例已经被回收。
- 加载该类的ClassLoader已经被回收。
- 该类的Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

*大量使用反射、动态代理、CGLib等ByteCode框架，动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景，需要虚拟机具备类卸载的功能。*

------

## 3.3 垃圾收集算法
 
### 标记-清除算法

主要分为标记和清除两个阶段。首先标记出所有需要回收的对象，标记完成后统一回收被标记的对象。

不足：
1. 标记和清除的效率都不高
2. 产生大量空间碎片

### 复制算法

将可用内存划分为相等的两块，当一块内存用完的时候，将存活的对象复制到另外一块上面，然后再把使用过的内存清空。

不足：
将原本的可用内存缩减了一半。

### 改进的复制算法

将内存分为一块较大的Eden空间和两块较小的Survivor空间，分别叫from和to，每次使用Eden和from空间。回收的时候，将Eden和Survivor中还存活的对象一次性地复制到to空间上，最后清理掉Eden和from空间，然后两个Survivor空间调换角色，from变成to，to变成from。HotSpot中，默认Eden和Survivor的空间比例是8:1。

当Survivor空间不够用时，需要依赖老年代进行分配担保（Handle Promotion）。

### 标记-整理算法

先标记，然后把存活的对象都向一端移动，清理掉边界以外的内存。

### 分代收集算法

根据对象存活周期将内存划分为几块，根据各个年代的特点采用适当的收集算法。

新生代用复制算法。老年代用标记-清理算法或者标记-整理算法。

---

## 3.4 HotSpot的算法实现

### 枚举根节点

可作为GC Roots的节点：
- 全局性的引用：如常量或类静态属性
- 执行上下文：栈帧中的本地变量表

可达性分析的两大难点：
- 当方法区很大的时候，逐个检查会消耗很多时间
- 分析工作必须在能确保一致性的快照中进行，也就必须停顿所有Java线程

HotSpot的优化方法：使用一组成为**OopMap**的数据结构来存放对象引用。在类加载完的时候，HotSpot把对象内什么偏移量是什么数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。这样在CG扫描时就知道哪些地方存放什么信息了。

### 安全点（Safe Point）

并非所有指令都会生成对应的OopMap，只会在**安全点**生成。安全点是程序执行时能够停下来进行GC的位置。安全点的选定以程序“是否具有让程序长时间执行的特征”为标准。长时间执行的最明显特征是指令序列复用，只有这些才会产生安全点。

当GC需要中断线程执行的时候，采用主动式中断的方法。设置一个标志，让线程执行的时候轮询这个标志，发现标志为真的时候，线程主动中断挂起。

### 安全区域（Safe Region）

安全区域指的是一段代码片段当中，引用关系不会发生变化，在这个区域的任意地方开始GC都是安全的。

当线程执行到安全区域的时候，首先标识自己进入了安全区域。GC不需要管处于安全区域的线程。线程离开安全区域的时候，需要检查系统是否完成根节点枚举或者GC，如果完成则继续执行，如果没有完成则必须等待离开信号。

## 3.5 垃圾收集器

HotSpot虚拟机中的垃圾收集器：

![HotSpot GC](/assets/pictures/studying/java_hotspot_garbage_collector.PNG)

收集器间的连线，代表着他们可以搭配使用

### Serial收集器

特点：
- 单线程
- 简单高效，拥有最高的收集效率
- Client模式下的默认收集器

缺点：
- 必须暂停其他线程的工作，也就是必须“Stop The World”。

### ParNew收集器

特点：
- 多线程版的Serial收集器
- 许多运行在Server模式下的首选收集器
- 只有它能与CMS收集器配合工作

### Parallel Scavenge收集器

目标：达到可控制的**吞吐量**。

吞吐量是CPU运行用户代码的时间与CPU总消耗时间的比值。但不意味着会有很短的停顿时间。

适合用于后台计算等不太需要太多交互的地方。

### Serial Old收集器

Serial收集器的老年代版本，使用标记-整理算法。

用途：
- 在JDK1.5之前与Parallel Scavenge收集器搭配使用
- 作为CMS收集器的后备预案

### Parallel Old收集器

Parallel Scavenge收集器的老年代版本，使用多线程和标记-整理算法。

在注重吞吐量和CPU资源敏感的场合，可以优先考虑Parallel Scavenge和Parallel Old组合。

### CMS收集器

目标：**获取最短回收停顿时间**。

算法：改进的标记-清除算法，分为如下四个步骤
1. 初始标记：需“Stop The World”，仅标记GC Roots能直接关联的对象。
2. 并发标记：多个线程进行GC Roots Tracing。
3. 重新标记：需“Stop The World”，修正并发标记期间用户程序变动的那部分对象标记。
4. 并发清除：多个线程进行清除工作。

特点：
- 耗时最长的并发标记和并发清除都是与用户线程并发执行的。
- 低停顿时间。

缺点：
- 对CPU资源非常敏感。占用部分线程导致吞吐量降低。
- 无法处理浮动垃圾，即在标记过程后的产生的垃圾。因此需要预留足够空间给用户线程。
- 基于标记-清除使得会有大量空间碎片产生。

### G1收集器

可能是最厉害的收集器。

特点：
- 并行与并发：充分利用多CPU多核环境的硬件优势，缩短“Stop The World”的时间。可以以并发的方式执行部分其他收集器需要停顿Java线程的GC动作。
- 分代收集：不需要其他收集器配合，管理整个GC堆
- 空间整合：基于标记-整理算法实现，从局部（两个Region之间）看是基于复制算法实现。
- 可预测的停顿：能让使用者明确指定在长度为M毫秒的时间内垃圾收集时间不会超过N毫秒。

G1收集器将堆划分为多个大小相等的**独立区域**（Region）。新生代老年代均是一部分Region的集合。G1跟踪各个Region里面垃圾堆积的价值大小，根据允许收集时间，优先回收价值最大的Region（G1-Garbage First的来由）。

Region之间的对象引用，虚拟机使用Remenbered Set来避免全对扫描。每个Region有一个Remembered Set。当虚拟机发现程序对Reference类型进行写操作时，暂时中断写操作，检查Reference对象是否处于Region之间，如果是，则通过CardTable把相关引用信息记录到对象所属的Region的Remembered Set中。

G1收集器的收集过程：
- 初始标记：除标记直接关联对象，还会修改TAMS（Next Top At Mark Start）的值，以便用户程序并发运行时，能在正确可用的Region中创建新对象。
- 并发标记
- 最终标记：除了修正标记以外，还会将这些修正记录在Remembered Set Logs里面。最后把Remembered Set Logs的数据合并到Remembered Set中。
- 筛选回收：对各个Region的回收价值和成本进行排序，根据用户期望的GC时间指定回收计划。

### 理解GC日志

> 33.125:[ GC[ DefNew: 3324K-＞152K（3712K）， 0.0025925 secs] 3324K-＞152K（11904K）， 0.0031680 secs]  
> 100.667:[ Full GC[ Tenured: 0K- ＞ 210K（10240K）， 0.0149142secs] 4603K-＞ 210K（19456K），[ Perm: 2999K- ＞ 2999K（21248K）]， 0.0150007 secs][ Times: user= 0. 01 sys= 0. 00， real= 0. 02 secs]

- 最前面的数字`33.125:`和`100.667`代表了自Java虚拟机启动以来，GC发生的时间。
- `[GC`和`[Full GC`表明停顿类型。Full代表有“Stop The World”的。
- `[DefNew`、`Tenured`、`Perm`表示GC的区域。区域名与垃圾收集器有关。
- 后面的`3324K->152K(3712K)`含义为：GC前该区域已使用容量->GC后已使用容量（该区域总容量）。方括号外面的则是Java堆的容量变化。
- `0.0025925 secs`代表GC的时间。后面的user，sys和real时间则是用户CPU时间，系统CPU时间，和现实时间。

-----

## 3.6 内存分配与回收策略

### 对象优先在Eden区分配



---



# 中间缺的几章内容慢慢补。

---


# 第八章

---

## 8.3节

### 静态分派

`Human man = new Man();`中，Human称为变量的**静态类型**或**外观类型**，而Man则是变量的**实际类型**。

虚拟机（严格说是编译器）在重载时通过参数的**静态类型** 作为判定依据。

所有依赖静态类型来定位方法执行版本的分派动作称为**静态分派**，典型有方法重载。

方法重载时，编译器确定应该调用的重载方法的优先级，基础类型的确定过程如下，举一个char类型的例子：

1. 类型一致的方法，如`fun(char c)`
2. 依据能够自动向上转换类型的顺序：`byte -> short, char -> int -> long -> float -> double`，依次匹配到的方法，如`fun(int c)`等。
3. 有对应的包装类作为参数的方法，如`fun (Character c)`。
4. 包装类实现的接口的方法，如Character类实现了Serializable方法，则匹配`fun(Serializable c)`。注意，同级如果有多个接口，编译器无法确定类型，会报错，拒绝编译。
5. 包装类继承链上最接近包装类的方法，Character的父类就是Object，因此可以匹配`fun(Object c)`。对Integer来说，则依次匹配`fun(Number i)`，`fun(Object i)`。
6. 有对应类型的变长参数的方法，如`fun(char... c)`。

关于更多的在重载中确定最合适方法的过程，需要看[*Java Language Specification*](http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12.2)中15.12.2.5节内容。

---

# 附加内容

## HotSpot虚拟机部分启动参数记录：

- **-Xms, -Xmx**：分别是堆的最小值和最大值参数。设置为一样时，堆不会自动扩展。若不一样，则会根据需要自动扩展。
- **-XX:+HeapDumpOnOutOfMemoryError**：指定虚拟机在内存溢出异常时Dump出当前的内存堆转出快照。
- **-Xss**：指定栈容量
- **-Xnoclassgc**：使虚拟机不回收类
- **-XX:+TraceClassLoading**：查看类的加载信息
- **-XX:+TraceClassUnLoading**：查看类的卸载信息
- **-verbose:class**：
- **-XX:SurvivorRatio**：
- **-XX:PretenureSizeThreshold**：
- **-XX:HandlePromotionFailure**：
- **-XX:ParallelGCThreads**：
- **-XX:MaxGCPauseMillis**：用于Parallel Scavenge收集器设置最大垃圾收集停顿时间。
- **-XX:GCTimeRatio**：用于Parallel Scavenge收集器设置吞吐量大小
- **-XX:UseAdaptiveSizePolicy**：用于Parallel Scavenge，打开以后，不需要手工指定新生代的大小。
- **-XX:UseCMSCompactAtFullCollection**：用于CMS收集器，在FullGC时执行内存碎片整理。
