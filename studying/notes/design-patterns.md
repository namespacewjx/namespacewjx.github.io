# 设计模式

<!-- vim-markdown-toc Redcarpet -->
* [结构型模式](#结构型模式)
    * [适配器模式](#适配器模式)
        * [意图](#意图)
        * [用途](#用途)
        * [结构](#结构)
        * [结果](#结果)
        * [实现](#实现)
        * [关联设计模式](#关联设计模式)
    * [桥接模式](#桥接模式)
        * [意图](#意图)
        * [动机](#动机)
        * [用途](#用途)
        * [结构](#结构)
        * [参与者](#参与者)

<!-- vim-markdown-toc -->

# 结构型模式

---

## 适配器模式

### 意图

将一个类的接口转换为客户期望的接口类型，使原本不兼容的类之间能够共同工作。

### 用途

- 当需要使用已经存在的类，并且该类的接口类型不符合你需要的类型时
- 当你需要创建一个与不相关的或者没预见过的类，也就是那些不一定有兼容接口的类，协作的可重用类时
- （只用于对象适配器）需要使用多个已存在的子类型，但是不可能适配每一个子类型。对象适配器能够适配父类型的接口。

### 结构

适配器分为两类，类适配器和对象适配器。

类适配器结构如下：
![class-adapter](/assets/pictures/studying/class-adapter.png)

对象适配器结构如下：
![object-adapter](/assets/pictures/studying/object-adapter.png)

### 结果

类适配器有以下结果
- 适配（继承）一个具体的类，相对的，无法同时适配该类和该类的子类
- 适配器能够重载被适配类的行为
- 只引入了一个对象，不需要指向被适配类的间接指针

对象适配器有如下结果
- 一个适配器能够适配多个被适配对象，也就是被适配类的对象及其子类的对象。另外也可以添加功能。
- 使修改被适配器类的行为变得困难。

另外还有几个点需要注意：
- 需要适配器做适配工作的量，取决于目标接口和被适配类之间的相似程度。
- 当最小化其他类为了使用一个类的时候需要做出的改变后，这个类的重用性就能够提升。这是成为可插拔适配器的基础。
- 双向适配器：适配器既适配被适配类，也适配客户类，这使得被适配类也能与客户类通过适配器类进行通信。

### 实现

- 适配器将会成为目标类的一个子类
- 要成为可插拔的适配器，就要找到一个被适配对象的最小的需要适配的接口子集。有三个方法可以实现
  - 目标或客户类中的抽象方法，适配器继承该类，并根据被适配类，实现这些抽象方法。
  - 使用委派对象。定义委派类的接口，该委派类就是适配目标，适配器实现该委派类。客户发送消息给该委派类的对象，来实现适配。
  - 使用参数化适配器。

### 关联设计模式

看上去，适配器模式跟桥接模式很相近，感觉两者都是在做统一接口的工作，把不同类各种各样的接口，转换为客户类所需要的那种接口。但是其实不完全相同，适配的前提就是，首先要有这样一个类去适配，就是适配已存在的类，把它的接口给转换了。而桥接模式，更多的是把接口和实现分离开来，实现怎么变都不会影响接口。

---

## 桥接模式

### 意图

把接口和实现解耦，让两者能够独立的变化。

### 动机

抽象类定义接口，多个实现类实现该抽象类，固然可以做到实现与接口分离。但是，这个方法也不够灵活，它将具体实现与这个接口的绑定起来了，当需要修改或者扩展接口，或者需要重用抽象类和接口的时候，就会变得麻烦。

桥接模式因此把接口和实现，放置在不同的类结构中，使得接口可以单独继承和变化，实现也能独立变化。这种情况下，实现类仅仅把接口最基本的方法实现，而更高层次的操作，则由接口的子类来定义，并根据抽象接口的各个方法来实现该高层次操作。

### 用途

当有如下情况时，使用桥接模式：
- 你需要避开接口和实现之间的绑定。比如说，运行时替换接口的实现。
- 接口和实现两个部分均需要通过继承的方式，进行独立的变化。这时候，桥接模式使你能够组合不同的接口和实现，并且独立的扩展它们。
- 实现的改变，不应该对客户类产生影响。
- 你需要在多个对象之间共享实现对象，并且，这个应该对客户透明。

### 结构

![桥接模式](/assets/pictures/studying/bridge-pattern.png)

### 参与者

- Abstraction
  - 定义抽象接口
  - 保存一个实现类对象的引用
- RefinedAbstraction
  - 扩展抽象接口
- Implementor
  - 实现抽象接口的方法。只实现最低级的抽象方法，抽象类定义更加高级的操作
- ConcreteImplementor
  - 具体实现实现类

