# 设计模式

GOF设计模式笔记。个人思考比较少，因为，还只是开始学习。。。

<!-- vim-markdown-toc Redcarpet -->
* [结构型模式](#结构型模式)
    * [适配器模式](#适配器模式)
        * [意图](#意图)
        * [用途](#用途)
        * [结构](#结构)
        * [结果](#结果)
        * [实现](#实现)
        * [关联设计模式](#关联设计模式)
    * [桥接模式](#桥接模式)
        * [意图](#意图)
        * [动机](#动机)
        * [用途](#用途)
        * [结构](#结构)
        * [参与者](#参与者)
    * [组合模式](#组合模式)
        * [意图](#意图)
        * [结构](#结构)
        * [用途](#用途)
        * [参与者](#参与者)
        * [协作](#协作)
        * [优缺点](#优缺点)
        * [实现](#实现)
    * [装饰器模式](#装饰器模式)
        * [意图](#意图)
        * [动机](#动机)
        * [用途](#用途)
        * [结构](#结构)
        * [参与者](#参与者)
        * [后果](#后果)
        * [实现](#实现)
    * [门面模式](#门面模式)
        * [意图](#意图)
        * [动机](#动机)
        * [用途](#用途)
        * [结构](#结构)
        * [参与者](#参与者)
        * [后果](#后果)
        * [实现](#实现)

<!-- vim-markdown-toc -->

# 结构型模式

---

## 适配器模式

### 意图

将一个类的接口转换为客户期望的接口类型，使原本不兼容的类之间能够共同工作。

### 用途

- 当需要使用已经存在的类，并且该类的接口类型不符合你需要的类型时
- 当你需要创建一个与不相关的或者没预见过的类，也就是那些不一定有兼容接口的类，协作的可重用类时
- （只用于对象适配器）需要使用多个已存在的子类型，但是不可能适配每一个子类型。对象适配器能够适配父类型的接口。

### 结构

适配器分为两类，类适配器和对象适配器。

类适配器结构如下：
![class-adapter](/assets/pictures/studying/class-adapter.png)

对象适配器结构如下：
![object-adapter](/assets/pictures/studying/object-adapter.png)

### 结果

类适配器有以下结果
- 适配（继承）一个具体的类，相对的，无法同时适配该类和该类的子类
- 适配器能够重载被适配类的行为
- 只引入了一个对象，不需要指向被适配类的间接指针

对象适配器有如下结果
- 一个适配器能够适配多个被适配对象，也就是被适配类的对象及其子类的对象。另外也可以添加功能。
- 使修改被适配器类的行为变得困难。

另外还有几个点需要注意：
- 需要适配器做适配工作的量，取决于目标接口和被适配类之间的相似程度。
- 当最小化其他类为了使用一个类的时候需要做出的改变后，这个类的重用性就能够提升。这是成为可插拔适配器的基础。
- 双向适配器：适配器既适配被适配类，也适配客户类，这使得被适配类也能与客户类通过适配器类进行通信。

### 实现

- 适配器将会成为目标类的一个子类
- 要成为可插拔的适配器，就要找到一个被适配对象的最小的需要适配的接口子集。有三个方法可以实现
  - 目标或客户类中的抽象方法，适配器继承该类，并根据被适配类，实现这些抽象方法。
  - 使用委派对象。定义委派类的接口，该委派类就是适配目标，适配器实现该委派类。客户发送消息给该委派类的对象，来实现适配。
  - 使用参数化适配器。

### 关联设计模式

看上去，适配器模式跟桥接模式很相近，感觉两者都是在做统一接口的工作，把不同类各种各样的接口，转换为客户类所需要的那种接口。但是其实不完全相同，适配的前提就是，首先要有这样一个类去适配，就是适配已存在的类，把它的接口给转换了。而桥接模式，更多的是把接口和实现分离开来，实现怎么变都不会影响接口。

---

## 桥接模式

### 意图

把接口和实现解耦，让两者能够独立的变化。

### 动机

抽象类定义接口，多个实现类实现该抽象类，固然可以做到实现与接口分离。但是，这个方法也不够灵活，它将具体实现与这个接口的绑定起来了，当需要修改或者扩展接口，或者需要重用抽象类和接口的时候，就会变得麻烦。

桥接模式因此把接口和实现，放置在不同的类结构中，使得接口可以单独继承和变化，实现也能独立变化。这种情况下，实现类仅仅把接口最基本的方法实现，而更高层次的操作，则由接口的子类来定义，并根据抽象接口的各个方法来实现该高层次操作。

### 用途

当有如下情况时，使用桥接模式：
- 你需要避开接口和实现之间的绑定。比如说，运行时替换接口的实现。
- 接口和实现两个部分均需要通过继承的方式，进行独立的变化。这时候，桥接模式使你能够组合不同的接口和实现，并且独立的扩展它们。
- 实现的改变，不应该对客户类产生影响。
- 你需要在多个对象之间共享实现对象，并且，这个应该对客户透明。

### 结构

![桥接模式](/assets/pictures/studying/bridge-pattern.png)

### 参与者

- Abstraction
  - 定义抽象接口
  - 保存一个实现类对象的引用
- RefinedAbstraction
  - 扩展抽象接口
- Implementor
  - 实现抽象接口的方法。只实现最低级的抽象方法，抽象类定义更加高级的操作
- ConcreteImplementor
  - 具体实现实现类

---

## 组合模式

### 意图

将一些对象组合进树形结构中，以表示部分-整体层次关系。组合模式使得用户能够一致对待单个对象和组合对象。

### 结构

![组合模式](/assets/pictures/studying/composite-pattern.png)

结构内关键的一点是，抽象类既代表一个普通组件，同时也是他们的容器。

### 用途

以下情况，使用组合模式。
- 需要表示出对象的部分-整体关系时。
- 希望客户类可以忽略单个对象和对象组合间的差异，一致的对待这两者。

### 参与者

- Component
  - 定义组合内对象的接口
  - 实现接口中所有类共有的默认方法
  - 声明如何获取和管理该组件的字组件的接口
  - （可选）定义一个接口方法来获取父对象
- Leaf
  - 表示组合中的叶子节点
  - 定义组合中原始对象的行为
- Composite
  - 定义有子女的组件的行为
  - 保存子女组件
  - 实现在组件接口中与子女有关的操作
- Client
  - 通过组件的接口操作组件对象

### 协作

客户使用抽象接口定义的方法来使用这些对象。使用原始对象时，在上面的操作由该原始对象完成。使用组合对象的一个原始操作时，则把这个原始操作的请求推给各个子对象。

### 优缺点

优点：
- 定义了能够包含原始对象和组合对象的结构
- 保持客户类简单
- 添加新类型组件变得容易

缺点：
- *让设计变得过于泛化*。让添加组件变得简单的副作用，就是让限制一些对象的组合更加困难。比如说，你需要限制其中一个组合组件类只能包含某几种组件，这不能通过静态类型来限制，只能通过运行时检查来做到。

### 实现

下面是需要在实现过程中考虑的一些点。

- *显式保存父对象引用*。子对象保存父对象引用能简化组合结构中的遍历以及管理操作。通常在抽象接口中，定义父对象的引用。为了保持父对象引用的正确性，只在一个对象被添加和移除的时候，修改父对象引用，这个方法可以在抽象类中实现，使得所有子类均可自动维持父对象的引用。
- *共享组件*。如果一个组件可以有多个父对象，共享组件会变得困难。享元模式能够解决这个问题。
- *最大化组件接口*。为了能够组合更多的组件，组件基类通常会最大化接口定义，然而这有时候违反类设计的一个原则，父类应该只定义对子类有意义的方法，有些方法对一些子类来说可能会很奇怪。比如叶子类不会有子对象，但是子对象管理方法却要实现，如果我们把叶子看成不会有子对象的节点，就知道那些方法该如何实现了。同样的，有时候需要换一个角度来思考，来解决接口默认实现的问题。
- *定义子对象管理操作*。该是在组件基类中定义这些操作，还是只在组合对象中定义呢？
  - 组合对象中定义，可以一致对待原始对象和组合对象。然而，有可能会对原始对象做一些无意义的子对象管理操作。
  - 在组合对象中定义更加安全，但是失去了透明性。
  - 在组合模式中，更加强调能够一致操作原始对象和组合对象的透明性。如果需要安全，就需要做类型转换工作。一些优雅的方法如下：
    - 在组件基类中定义一个GetComposite操作，默认返回空指针（引用）。这个方法可以测试这个对象是否是组合对象。
- *是否需要组件基类维持一个组件列表*。如果是，这会给叶子节点带来无谓的空间代价。
- *子对象排序*。许多设计会指定组合对象中子对象的排序，如果需要排序，需要谨慎设计子对象的获取操作。可以使用迭代器模式解决。
- *缓存以提升性能*。如果需要频繁的搜索和遍历组合，可以利用缓存。
- *谁来删除组件呢*？
- *储存子对象的最佳数据结构是哪一种*？

---

## 装饰器模式

### 意图

动态的给一个对象添加额外的职责。装饰器提供了继承之外的扩展功能的可选项。

### 动机

有时候我们需要给单个对象添加职责，而不是给一整个类。

装饰器遵从其装饰的组件的接口定义，以做到对组件的客户类透明。装饰器把请求送给组件，并且可以在此之前或之后做一些额外的动作。

### 用途

如下情况，使用装饰器模式
- 为给单个对象动态的，对客户透明的添加职责，不影响其他对象
- 某一责任可以被去除
- 当使用继承来扩展功能不切实际时。比如，有时候有大量的扩展可以使用，如果使用继承，不同的扩展的组合，就会引发子类爆发性增长，另外，子类的定义，也在继承中被隐藏，甚至不能用了。

### 结构

![装饰器模式](/assets/pictures/studying/decorator-pattern.png)

### 参与者

- Component
  - 定义对象的接口，该接口可以让职责被动态的加进去对象中。
- ConcreteComponent
  - 定义实际对象，可以为其添加职责。
- Decorator
  - 维护组件对象的引用，并且定义一个符合组件接口定义的装饰器接口。
- ConcreteDecorator
  - 给组件添加实际的职责

### 后果

- *比静态继承更强的灵活性*。职责能够在运行时动态的加载进去，并且能够混合多个职责，还能够添加两次职责。
- *避免了拥有许多功能的类在层次结构的高处*。装饰器可以让你定义一个简单的类，通过给其添加装饰器，来添加许多的功能，也能避免混入了一些不需要用到的功能。此外，定义装饰器也比较简单。
- *装饰器和组件不同*。他们的区别仅在于如何互相连接的。

### 实现

下面是一些注意的点。

- 要符合组件的接口定义。
- 在只需要添加一个职责的时候，没必要定义装饰器。
- 保持组件类的轻量化。组件类的抽象基类，仅需要定义接口，而不是数据。如果该类太过复杂，就会造成装饰器类过于重量级，不利于添加多个装饰器类。
- 改变一个对象的外表，还是改变对象的内部实现？装饰器改变外表，而策略模式则改变内在实现。策略模式能够适用于重量级组件对象，定义其自身的接口，不需要符合组件的接口。

---

## 门面模式

### 意图

提供子系统中一系列接口的统一接口。门面对象定义了一个让子系统易于使用的高层接口。

### 动机

把一个系统划分为各个子系统有助于降低复杂度。一个共同不妙是最小化子系统之间的连接和依赖。

门面对象为子系统通用的功能，提供了一个单一的、简单的接口。

### 用途

如下情况，使用门面模式
- *提供复杂子系统的简单接口*。随着设计的进行，子系统会变得越来越复杂，这对于仅仅使用子系统功能的客户类来说不友好，提供一个门面对象，有助于给大部分客户类一个简单默认的子系统的视图。只有需要扩展子系统功能的类，才需要越过门面，与内部类打交道。
- 客户类和抽象类之间的依赖过多，门面模式有助于降低子系统之间的耦合，提高他们的独立性和便携性。
- 需要层次化你的系统时。使用门面对象给每一层一个入口，子系统之间只通过这个入口来交流。

### 结构

![门面模式](/assets/pictures/studying/facede-pattern.png)

### 参与者

- Facade
  - 清楚子系统中哪一些类处理某一种请求
  - 委派客户类的请求到合适的子系统对象
- Subsystem Classes
  - 实现子系统的功能
  - 处理门面对象发来的请求
  - 对门面对象的存在不知情，没有对其的引用

### 后果

有如下优点：
- 把客户类和子系统类隔开，减少了客户类需要与子系统要打交道的类，使子系统更易于使用。
- 提供子系统和客户类之间的弱耦合关系。通常子系统内部是强耦合的，弱耦合使得你可以修改子系统内部实现，而对客户类没有影响。门面模式也可以减少编译时候的依赖关系，简化将子系统用于其他系统的过程。
- 没有阻止外部类对子系统内部类的访问。

### 实现

实现时，需要考虑如下问题。
- 减少子系统与客户类之间耦合。可以把门面对象设计成抽象类，更进一步降低耦合，继承类针对不同子系统的实现来设计实现。另外，也可以使用不同的子系统对象来配置门面对象。
- 子系统类的公开访问还是私有访问。公开接口是客户类能够访问的，私有接口则提供给子系统的扩展类来使用。要思考一个类的接口究竟要公开，还是私有。


