# 设计模式

GOF《设计模式》笔记。更多是摘录（翻译）和总结。所有配图均来自《设计模式》中文版图书。


<!-- vim-markdown-toc Redcarpet -->
* [结构型模式](#结构型模式)
    * [适配器模式](#适配器模式)
        * [意图](#意图)
        * [用途](#用途)
        * [结构](#结构)
        * [结果](#结果)
        * [实现](#实现)

<!-- vim-markdown-toc -->

# 结构型模式

## 适配器模式

### 意图

将一个类的接口转换为客户期望的接口类型，使原本不兼容的类之间能够共同工作。

### 用途

- 当需要使用已经存在的类，并且该类的接口类型不符合你需要的类型时
- 当你需要创建一个与不相关的或者没预见过的类，也就是那些不一定有兼容接口的类，协作的可重用类时
- （只用于对象适配器）需要使用多个已存在的子类型，但是不可能适配每一个子类型。对象适配器能够适配父类型的接口。

### 结构

适配器分为两类，类适配器和对象适配器。

类适配器结构如下：
![class-adapter](/assets/pictures/studying/class-adapter.png)

对象适配器结构如下：
![object-adapter](/assets/pictures/studying/object-adatper.png)

### 结果

类适配器有以下结果
- 适配（继承）一个具体的类，相对的，无法同时适配该类和该类的子类
- 适配器能够重载被适配类的行为
- 只引入了一个对象，不需要指向被适配类的间接指针

对象适配器有如下结果
- 一个适配器能够适配多个被适配对象，也就是被适配类的对象及其子类的对象。另外也可以添加功能。
- 使修改被适配器类的行为变得困难。

另外还有几个点需要注意：
- 需要适配器做适配工作的量，取决于目标接口和被适配类之间的相似程度。
- 当最小化其他类为了使用一个类的时候需要做出的改变后，这个类的重用性就能够提升。这是成为可插拔适配器的基础。
- 双向适配器：适配器既适配被适配类，也适配客户类，这使得被适配类也能与客户类通过适配器类进行通信。

### 实现

- 适配器将会成为目标类的一个子类
- 要成为可插拔的适配器，就要找到一个被适配对象的最小的需要适配的接口子集。有三个方法可以实现
  - 目标或客户类中的抽象方法，适配器继承该类，并根据被适配类，实现这些抽象方法。
  - 使用委派对象。定义委派类的接口，该委派类就是适配目标，适配器实现该委派类。客户发送消息给该委派类的对象，来实现适配。
  - 使用参数化适配器。
