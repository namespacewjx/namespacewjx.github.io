---
title: JVM学习笔记
date: 2017-03-28 19:25:03 +0800
# 第三章 垃圾收集器与内存分配策略

---

<!-- vim-markdown-toc Redcarpet -->
* [第三章](#第三章)
    * [3-2 判断对象存活与否的算法](#3-2-判断对象存活与否的算法)
        * [引用计数算法](#引用计数算法)
        * [可达性分析算法](#可达性分析算法)
        * [再谈引用](#再谈引用)
        * [判断对象死亡](#判断对象死亡)
        * [回收方法区](#回收方法区)
    * [3-3 垃圾收集算法](#3-3-垃圾收集算法)
        * [标记-清除算法](#标记-清除算法)
        * [复制算法](#复制算法)
        * [改进的复制算法](#改进的复制算法)
        * [标记-整理算法](#标记-整理算法)
        * [分代收集算法](#分代收集算法)
    * [3-4 HotSpot的算法实现](#3-4-hotspot的算法实现)
        * [枚举根节点](#枚举根节点)
        * [安全点（Safe Point）](#安全点（safe-point）)
        * [安全区域（Safe Region）](#安全区域（safe-region）)
    * [3-5 垃圾收集器](#3-5-垃圾收集器)
        * [Serial收集器](#serial收集器)
        * [ParNew收集器](#parnew收集器)
        * [Parallel Scavenge收集器](#parallel-scavenge收集器)
        * [Serial Old收集器](#serial-old收集器)
        * [Parallel Old收集器](#parallel-old收集器)
        * [CMS收集器](#cms收集器)
        * [G1收集器](#g1收集器)
        * [理解GC日志](#理解gc日志)
    * [3-6 内存分配与回收策略](#3-6-内存分配与回收策略)
        * [对象优先在Eden区分配](#对象优先在eden区分配)
            * [Minor GC和Full GC](#minor-gc和full-gc)
        * [大对象直接进入老年代](#大对象直接进入老年代)
        * [长期存活的对象将进入老年代](#长期存活的对象将进入老年代)
        * [动态对象年龄判定](#动态对象年龄判定)
        * [空间分配担保](#空间分配担保)
* [第四章 虚拟机性能监控及故障处理工具](#第四章-虚拟机性能监控及故障处理工具)
    * [4-1 概述](#4-1-概述)
    * [4-2 JDK的命令行工具](#4-2-jdk的命令行工具)
        * [jps-虚拟机进程状况工具](#jps-虚拟机进程状况工具)
        * [jstat-虚拟机统计信息监视工具](#jstat-虚拟机统计信息监视工具)
        * [jinfo-Java配置信息工具](#jinfo-java配置信息工具)
        * [jmap-Java内存映像工具](#jmap-java内存映像工具)
* [中间缺的几章内容慢慢补](#中间缺的几章内容慢慢补)
* [第八章](#第八章)
    * [8-3节](#8-3节)
        * [静态分派](#静态分派)
* [附加内容](#附加内容)
    * [HotSpot虚拟机部分启动参数记录](#hotspot虚拟机部分启动参数记录)

<!-- vim-markdown-toc -->

# 第三章

## 3-2 判断对象存活与否的算法

下面的算法是确定对象哪些存活，哪些死去

### 引用计数算法

**过程**：给对象添加一个引用计数器，每当有一个地方引用时，给计数器加1；引用失效时，计数器见1。当计数器的值为0时，对象是不可能再被使用了。

不能解决对象之间的循环引用问题，也就是当两个对象互相拥有对方的引用的时候，导致引用计数器不为0。

### 可达性分析算法

**过程**：通过一系列成为“GC Roots”的对象作为起始点，从这些节点开始乡下搜索，搜索时走过的路径称为**引用链**（Reference Chain），当一个对象没有任何引用链相连，也就是从GC Roots到这个对象不可达时，则这个对象是不可用的。

Java中，可以做GC Roots的对象有：
- 虚拟机栈（栈帧中的本地变量表）中引用的对象。
- 方法区中类静态属性引用的对象。
- 方法区中常量引用的对象。

### 再谈引用

Java引用分为如下几种：
- **强引用**：直接声明使用的对象的引用。
- **软引用**：描述有用但是并非必须的对象。在内存溢出之前，回收这些软引用的对象。
- **弱引用**：同时非必须对象，但是比软引用更弱。会在下一次垃圾回收过程中被回收。
- **虚引用**：最弱的引用关系，不会对对象生存时间构成影响，无法获得这个对象实例。唯一目的是在被回收前获得一个系统通知。

### 判断对象死亡

1. 对象在可达性分析后，发现没有与GC Roots相连的引用链，对象第一次被标记并进行筛选。筛选的过程是判断有没有必要执行`finalize()`方法。若没有覆盖这个方法，或者已被调用过，则没有必要执行，对象已死。
2. 通过筛选的对象，会被放在叫做`F-Queue`的队列之中，并稍后会由一个由虚拟机建立的低优先级的Finalizer线程去执行对象的`finalize()`方法。注意，虚拟机会触发这个方法，但是**不会等待它运行结束**。之后，GC会对`F-Queue`中的对象进行第二次小规模的标记，若对象的`finalize()`方法让其重新与引用链上的任何一个对象建立了关联，则对象存活。否则死亡。

*`finalize()`方法不是C++的析构方法，不能保证会运行，尽量避免使用*

### 回收方法区

垃圾回收主要收集**废弃常量**和**无用的类**。

无用类的判定条件：
- 该类的所有实例已经被回收。
- 加载该类的ClassLoader已经被回收。
- 该类的Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

*大量使用反射、动态代理、CGLib等ByteCode框架，动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景，需要虚拟机具备类卸载的功能。*

------

## 3-3 垃圾收集算法
 
### 标记-清除算法

主要分为标记和清除两个阶段。首先标记出所有需要回收的对象，标记完成后统一回收被标记的对象。

不足：
1. 标记和清除的效率都不高
2. 产生大量空间碎片

### 复制算法

将可用内存划分为相等的两块，当一块内存用完的时候，将存活的对象复制到另外一块上面，然后再把使用过的内存清空。

不足：
将原本的可用内存缩减了一半。

### 改进的复制算法

将内存分为一块较大的Eden空间和两块较小的Survivor空间，分别叫from和to，每次使用Eden和from空间。回收的时候，将Eden和Survivor中还存活的对象一次性地复制到to空间上，最后清理掉Eden和from空间，然后两个Survivor空间调换角色，from变成to，to变成from。HotSpot中，默认Eden和Survivor的空间比例是8:1。

当Survivor空间不够用时，需要依赖老年代进行分配担保（Handle Promotion）。

### 标记-整理算法

先标记，然后把存活的对象都向一端移动，清理掉边界以外的内存。

### 分代收集算法

根据对象存活周期将内存划分为几块，根据各个年代的特点采用适当的收集算法。

新生代用复制算法。老年代用标记-清理算法或者标记-整理算法。

---

## 3-4 HotSpot的算法实现

### 枚举根节点

可作为GC Roots的节点：
- 全局性的引用：如常量或类静态属性
- 执行上下文：栈帧中的本地变量表

可达性分析的两大难点：
- 当方法区很大的时候，逐个检查会消耗很多时间
- 分析工作必须在能确保一致性的快照中进行，也就必须停顿所有Java线程

HotSpot的优化方法：使用一组成为**OopMap**的数据结构来存放对象引用。在类加载完的时候，HotSpot把对象内什么偏移量是什么数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。这样在CG扫描时就知道哪些地方存放什么信息了。

### 安全点（Safe Point）

并非所有指令都会生成对应的OopMap，只会在**安全点**生成。安全点是程序执行时能够停下来进行GC的位置。安全点的选定以程序“是否具有让程序长时间执行的特征”为标准。长时间执行的最明显特征是指令序列复用，只有这些才会产生安全点。

当GC需要中断线程执行的时候，采用主动式中断的方法。设置一个标志，让线程执行的时候轮询这个标志，发现标志为真的时候，线程主动中断挂起。

### 安全区域（Safe Region）

安全区域指的是一段代码片段当中，引用关系不会发生变化，在这个区域的任意地方开始GC都是安全的。

当线程执行到安全区域的时候，首先标识自己进入了安全区域。GC不需要管处于安全区域的线程。线程离开安全区域的时候，需要检查系统是否完成根节点枚举或者GC，如果完成则继续执行，如果没有完成则必须等待离开信号。

----

## 3-5 垃圾收集器

HotSpot虚拟机中的垃圾收集器：

![HotSpot GC](/assets/pictures/studying/java_hotspot_garbage_collector.PNG)

收集器间的连线，代表着他们可以搭配使用

### Serial收集器

特点：
- 单线程
- 简单高效，拥有最高的收集效率
- Client模式下的默认收集器

缺点：
- 必须暂停其他线程的工作，也就是必须“Stop The World”。

### ParNew收集器

特点：
- 多线程版的Serial收集器
- 许多运行在Server模式下的首选收集器
- 只有它能与CMS收集器配合工作

### Parallel Scavenge收集器

目标：达到可控制的**吞吐量**。

吞吐量是CPU运行用户代码的时间与CPU总消耗时间的比值。但不意味着会有很短的停顿时间。

适合用于后台计算等不太需要太多交互的地方。

### Serial Old收集器

Serial收集器的老年代版本，使用标记-整理算法。

用途：
- 在JDK1.5之前与Parallel Scavenge收集器搭配使用
- 作为CMS收集器的后备预案

### Parallel Old收集器

Parallel Scavenge收集器的老年代版本，使用多线程和标记-整理算法。

在注重吞吐量和CPU资源敏感的场合，可以优先考虑Parallel Scavenge和Parallel Old组合。

### CMS收集器

目标：**获取最短回收停顿时间**。

算法：改进的标记-清除算法，分为如下四个步骤
1. 初始标记：需“Stop The World”，仅标记GC Roots能直接关联的对象。
2. 并发标记：多个线程进行GC Roots Tracing。
3. 重新标记：需“Stop The World”，修正并发标记期间用户程序变动的那部分对象标记。
4. 并发清除：多个线程进行清除工作。

特点：
- 耗时最长的并发标记和并发清除都是与用户线程并发执行的。
- 低停顿时间。

缺点：
- 对CPU资源非常敏感。占用部分线程导致吞吐量降低。
- 无法处理浮动垃圾，即在标记过程后的产生的垃圾。因此需要预留足够空间给用户线程。
- 基于标记-清除使得会有大量空间碎片产生。

### G1收集器

可能是最厉害的收集器。

特点：
- 并行与并发：充分利用多CPU多核环境的硬件优势，缩短“Stop The World”的时间。可以以并发的方式执行部分其他收集器需要停顿Java线程的GC动作。
- 分代收集：不需要其他收集器配合，管理整个GC堆
- 空间整合：基于标记-整理算法实现，从局部（两个Region之间）看是基于复制算法实现。
- 可预测的停顿：能让使用者明确指定在长度为M毫秒的时间内垃圾收集时间不会超过N毫秒。

G1收集器将堆划分为多个大小相等的**独立区域**（Region）。新生代老年代均是一部分Region的集合。G1跟踪各个Region里面垃圾堆积的价值大小，根据允许收集时间，优先回收价值最大的Region（G1-Garbage First的来由）。

Region之间的对象引用，虚拟机使用Remenbered Set来避免全对扫描。每个Region有一个Remembered Set。当虚拟机发现程序对Reference类型进行写操作时，暂时中断写操作，检查Reference对象是否处于Region之间，如果是，则通过CardTable把相关引用信息记录到对象所属的Region的Remembered Set中。

G1收集器的收集过程：
- 初始标记：除标记直接关联对象，还会修改TAMS（Next Top At Mark Start）的值，以便用户程序并发运行时，能在正确可用的Region中创建新对象。
- 并发标记
- 最终标记：除了修正标记以外，还会将这些修正记录在Remembered Set Logs里面。最后把Remembered Set Logs的数据合并到Remembered Set中。
- 筛选回收：对各个Region的回收价值和成本进行排序，根据用户期望的GC时间指定回收计划。

### 理解GC日志

> 33.125:[ GC[ DefNew: 3324K-＞152K（3712K）， 0.0025925 secs] 3324K-＞152K（11904K）， 0.0031680 secs]  
> 100.667:[ Full GC[ Tenured: 0K- ＞ 210K（10240K）， 0.0149142secs] 4603K-＞ 210K（19456K），[ Perm: 2999K- ＞ 2999K（21248K）]， 0.0150007 secs][ Times: user= 0. 01 sys= 0. 00， real= 0. 02 secs]

- 最前面的数字`33.125:`和`100.667`代表了自Java虚拟机启动以来，GC发生的时间。
- `[GC`和`[Full GC`表明停顿类型。Full代表有“Stop The World”的。
- `[DefNew`、`Tenured`、`Perm`表示GC的区域。区域名与垃圾收集器有关。
- 后面的`3324K->152K(3712K)`含义为：GC前该区域已使用容量->GC后已使用容量（该区域总容量）。方括号外面的则是Java堆的容量变化。
- `0.0025925 secs`代表GC的时间。后面的user，sys和real时间则是用户CPU时间，系统CPU时间，和现实时间。

-----

## 3-6 内存分配与回收策略

### 对象优先在Eden区分配

大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一起Minor GC。

#### Minor GC和Full GC

- 新生代GC（Minor GC）：指发生在新生代的垃圾收集动作。Java对象大多是朝生夕灭的，因此Minor GC非常频繁，而回收速度也比较快。
- 老年代GC（Major GC/Full GC）：指发生在老年代的GC。出现Major GC，可能会伴随一次Minor GC，看垃圾收集器的策略）。速度比Minor GC慢10倍以上。

### 大对象直接进入老年代

大对象指的是，需要大量连续内存空间的Java对象，如长字符串和数组。写程序的时候，应该避免使用朝生夕灭的短命大对象。

为了减少Eden区和Survivor区之间发生大量的内存复制，避免大对象容易导致垃圾收集提前触发的问题，直接把大对象分到老年代中。

### 长期存活的对象将进入老年代

为了识别对象应该放在新生代还是老年代，虚拟机给每个对象定义了对象年龄计数器。若对象在Eden新生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将会被移动到Survivor中，对象年龄设为1。对象每熬过一次Minor GC，年龄就增加1。当对象年龄增加的一定的程度（默认15岁），就会被晋升到老年代中。这个阈值由MaxTenuringThreshold控制。

### 动态对象年龄判定

虚拟机并不是一直要求对象年龄到达MaxTenuringThreshold才会晋升老年代。若在Survivor空间内，相同年龄的对象大小总和占到了Survivor空间的一半，年龄大于或等于该年龄的对象，就会直接进入老年代。

### 空间分配担保

在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，若成立，则Minor GC是安全的。若不成立，虚拟机会查看HandlePromotionFailure设置值是否允许担保失败，若允许，则会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，若大于，将会进行一个Minor GC，尽管这是有风险的。若前面条件不成立，则进行一次Full GC。

此处风险指的是，若在一次Minor GC过程中，有大量对象存活，Survivor空间不足，就需要老年代进行分配担保，以把Survivor无法容纳的对象放入老年代。而要进行分配担保，老年代必须有足够的空间容纳，但是存活对象的数量无法在完成回收前确定，因此只好取每次晋升到老年代的对象平均大小作为经验值，与老年代剩余空间进行比较，以决定是否进行Full GC腾出空间。

若某次Minor GC后存活对象突增，超过平均值的话，会导致担保失败，只能重新发起Full GC。

---

# 第四章 虚拟机性能监控及故障处理工具

---

## 4-1 概述

定位系统问题时，需要的数据包括：
- 运行日志
- 异常堆栈
- GC日志
- 线程快照（threaddump/javacore文件）
- 堆转储快照（headdump/hprof文件）

---

## 4-2 JDK的命令行工具

在JDK的bin文件夹下，有着JDK官方的各种工具，如下表

Sun JDK监控与故障处理工具
|名称|主要作用|
|jps|JVM Process Status Tool，显示指定系统内所有的HotSpot虚拟机进程|
|jstat|JVM Statistics Monitoring Tool，用于手机HotSpot虚拟机各方面的运行数据|
|jinfo|Configuration Info for Java，显示虚拟机配置信息|
|jmap|Memory Map for Java，生成虚拟机的内存转储快照（heapdump文件）|
|jhat|JVM Heap Dump Browser，用于分析heapdump文件，它会建立一个HTTP/HTML服务器，让用户可以在浏览器上查看分析结果|
|jstack|Stack Trace for Java，显示虚拟机的线程快照|

### jps-虚拟机进程状况工具

作用：列出正在运行的虚拟机进程，并显示虚拟机执行主类（Main Class,`main()`函数所在的类）名称以及这些进程的本地虚拟机唯一ID（Local Virtual Machine Identifier, LVMID）。

其他JDK工具的查询，大多需要LVMID来确定监控哪个虚拟机进程。对于本地虚拟机进程来说，LVMID与操作系统的进程ID是一致的。

jps命令格式：`jps [options] [hostid]`

`hostid`是RMI注册表中注册的主机名。

选项：
- -q：仅输出LVMID，省略主类名
- -m：输出虚拟机启动时传递给`main()`函数的参数
- -l：输出主类的全名，若进行执行的是jar包，输出jar路径
- -v：输出虚拟机进程启动时的JVM参数

### jstat-虚拟机统计信息监视工具

作用：显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据

命令格式：`jstat [option vmid[interval[s|ms] [count]]]`

vmid的说明：若是本地虚拟机进程，vmid与LVMID是一致的，若是远程虚拟机进程，vmid的格式是：`[protocol:][//]lvmid[@hostname[:port]/servername]`。interval和count代表查询间隔和查询次数，若忽略，则只查询一次。

options代表用户希望查询的虚拟机信息，如下：
- -class：监视类装载，装载数量，总空间以及类装载所耗费的时间
- -gc：监视Java堆状况，包括Eden区、两个Survivor区、老年代、永久代等的容量，已用空间，GC时间合计等信息
- -gccapacity：监视内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大、最小空间
- -gcutil：监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比
- -gccause：与-gcutil一样，但是会额外输出导致上一次GC产生的原因
- -gcnew：监视新生代GC状况
- -gcnewcapacity：监视内容与-gcnew基本相同，主要关注使用到的最大最小空间
- -gcold：监视老年代GC状况
- -gcoldcapacity：监视内容与-gcold基本相同，主要关注使用到的最大最小空间
- -gcpermcapacity：输出永久代使用到的最大、最小空间
- -compiler：输出JIT编译器编译过的方法、耗时等信息
- -printcompilation：输出已经被JIT编译的方法

### jinfo-Java配置信息工具

格式：jinfo [option] pid

选项：
- -flag：显示未被显式指定的参数的系统默认值
- -sysprops：打印虚拟机进程的`System.getProperties()`内容
- -flag [+|-]*name*或者-flag *name*=*value*：修改运行期虚拟机参数

### jmap-Java内存映像工具

用于生产堆转储快照（heapdump或dump文件），查询finalize执行队列、Java堆和永久代的详细信息，如空间使用率、当前用的垃圾收集器等

格式：jmap [option] vmid

选项：
- -dump：生成Java堆转储快照。格式为：-dump:[live, ]format=b, file=*filename*，其中live子参数说明是否只dump出存活的对象
- -finalizerinfo：显示在F-Queue中等待Finalizer线程执行finalize方法的对象。
- -heap：显示Java堆详细信息，如使用哪种回收器、参数配置、分代状况等
- -histo：显示堆中对象统计信息，包装类、实例数量、合计容量
- -permstat：以ClassLoader为统计口径显示永久代内存状态
- -F：当虚拟机进程对-dump选项没有响应时，可使用这个选项强制生成dump快照



---


# 中间缺的几章内容慢慢补

---


# 第八章

---

## 8-3节

### 静态分派

`Human man = new Man();`中，Human称为变量的**静态类型**或**外观类型**，而Man则是变量的**实际类型**。

虚拟机（严格说是编译器）在重载时通过参数的**静态类型** 作为判定依据。

所有依赖静态类型来定位方法执行版本的分派动作称为**静态分派**，典型有方法重载。

方法重载时，编译器确定应该调用的重载方法的优先级，基础类型的确定过程如下，举一个char类型的例子：

1. 类型一致的方法，如`fun(char c)`
2. 依据能够自动向上转换类型的顺序：`byte -> short, char -> int -> long -> float -> double`，依次匹配到的方法，如`fun(int c)`等。
3. 有对应的包装类作为参数的方法，如`fun (Character c)`。
4. 包装类实现的接口的方法，如Character类实现了Serializable方法，则匹配`fun(Serializable c)`。注意，同级如果有多个接口，编译器无法确定类型，会报错，拒绝编译。
5. 包装类继承链上最接近包装类的方法，Character的父类就是Object，因此可以匹配`fun(Object c)`。对Integer来说，则依次匹配`fun(Number i)`，`fun(Object i)`。
6. 有对应类型的变长参数的方法，如`fun(char... c)`。

关于更多的在重载中确定最合适方法的过程，需要看[*Java Language Specification*](http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12.2)中15.12.2.5节内容。

---

# 附加内容

## HotSpot虚拟机部分启动参数记录

- **-Xms, -Xmx**：分别是堆的最小值和最大值参数。设置为一样时，堆不会自动扩展。若不一样，则会根据需要自动扩展。
- **-XX:+HeapDumpOnOutOfMemoryError**：指定虚拟机在内存溢出异常时Dump出当前的内存堆转出快照。
- **-Xss**：指定栈容量
- **-Xnoclassgc**：使虚拟机不回收类
- **-XX:+TraceClassLoading**：查看类的加载信息
- **-XX:+TraceClassUnLoading**：查看类的卸载信息
- **-verbose:class**：
- **-XX:SurvivorRatio**：Eden区一个与Survivor区的比值
- **-XX:HandlePromotionFailure**：设置时允许老年代空间分配担保失败
- **-XX:ParallelGCThreads**：
- **-XX:MaxGCPauseMillis**：用于Parallel Scavenge收集器设置最大垃圾收集停顿时间。
- **-XX:GCTimeRatio**：用于Parallel Scavenge收集器设置吞吐量大小
- **-XX:UseAdaptiveSizePolicy**：用于Parallel Scavenge，打开以后，不需要手工指定新生代的大小。
- **-XX:UseCMSCompactAtFullCollection**：用于CMS收集器，在FullGC时执行内存碎片整理。
- **-XX:+PrintGCDetails**：发生垃圾收集时，打印内存回收日志，并且在进程退出的时候，输出当前的内存各区域分配情况
- **-XX:PretenureSizeThreshold**：大于此设置值的对象，直接在老年代分配。只对Serial和ParNew两款收集器有效。
- **-XX:MaxTenuringThreshold**：晋升老年代的年龄阈值
- **-XX:+PrintFlagsFinal**：查看JVM参数默认值
- **-XX:+HeapDumpOnCtrlBreak**：可以在虚拟机运行过程中，按下[Ctrl]+[Break]按键，让虚拟机生成dump文件
