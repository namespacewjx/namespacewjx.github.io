---
layout:     post
title:      "以字节为单位进行大小写转换"
author:     "吴俊贤"
tags:
    - 算法
    - 字符串
---

以小写转换大写为例子

# 字节操作

这个小写转换，很容易就知道，给每一位都减去`'a'-'A'`的值，也就是32即可。换成字节的话，直接减去`0x20202020`即可。

话说当初设计ASCII表的时候，故意把大小写字母的间隔调整为32的吗，这样子这个差值就只有一个bit是1了，做很多运算都非常方便，比如接下来的。

难就难在，我们不能把非小写的字母改掉，这就带来了问题，我们需要判断：每一个字节都在[97,122]这个区间内。

# 判断字节是否大于等于97

我们不可能一个一个字节的判断，这样就回到了一个一个字节的处理方法上了，我们要用32比特的整数。

那么跟刚才减去`0x20202020`这个做法类似，我减去每个字节都是97的数，也就是`0x61616161`。但是，我们*不能直接减`0x61616161`* 。减法的实现就是加上负的减数，而我们知道，负数在计算机里面是以补码形式存储的。补码是取反然后加1，我把`0x61616161`取反加一之后，得到的数是`0x9E9E9E9F`，就不是本来那个每个字节字节减去97的效果了。我们应该用-97的补码表示，取得这个加的数，也就是`0x9F9F9F9F`，这样就是每一个位都减了97。

比如，`0x61626364`的输入，得到的是`0x01020303`，高位都是0，说明这些数，都大于等于97。

但是，还有一个问题，不知道大家发现了没有。

两个二进制数相减，变成一个数加上一个负的另一个数，如果得到一个正的结果，将会有一个进位1产生。这在字节操作是没有这个问题的，进位1因为超出了字节，被忽略了。

**但是，在这里就有问题了。**

这个进位1，加到了下一个字节里面去，把本来加的结果给继续加了1。如果我输入，`0x60616161`的话，我得到的，就是`0x00010100`，最高的字节居然是0了！`0x60`是小于97的，产生了错误的结果。

因此，我们必须减去进位。

进位的获取也很简单，只需要加上`0x9F9F9F9F`之后，一样与上`0x80808080`取字节最高位，然后再取反，因为最高位为0的是有进位的，我们取反让进位1出现了。再向左移1位，对齐下一个字节的数。然后，用原本加完了`0x9F9F9F9F`的数，减去这个得到的进位，就是本来应该是的结果了。

比如，还是`0x60616161`这个例子，按照下列步骤处理。

1. 加上`0x9F9F9F9F`得到`0x00010100`
2. 取得最高位，与上`0x80808080`，得到`0`
3. 取反，异或`0x80808080`，得到`0x80808080`
4. 左移1位，得到`0x01010100`
5. 用`0x00010100`减去`0x01010100`，就得到应该得到的结果，`0xFF000000`
6. `0xFF000000`与上`0x80808080`，得到结果，`0x80000000`
7. `0x80000000`右移2位，得到`0x20000000`
8. `0x20000000`异或`0x20202020`，得到最终结果`0x00202020`

经过这几个步骤之后，我们去掉了第一个字节的32，第一个字节就不需要减去32了。

# 判断字节是否小于等于122

做法与上面是类似的，只需要每一位加上-123，也就是`0x85`

# 减去处理完的0x20

在处理完`0x20202020`得到最终的减数之后，我们终于可以使用本来的数字，减去这个的出来的减数，以变成大写了。

# 时间性能对比

用了下面两个用例函数来测试了下性能

```go
func BenchmarkToUpperCaseUnsafe(b *testing.B) {
	str := "@ABCDEFGHIJKLMNOPQRSTUVWXYZ_`abcdefghijklmnopqrstuvwxyz{|}"
	for i := 0; i < 1000; i++ {
		str += "@ABCDEFGHIJKLMNOPQRSTUVWXYZ_`abcdefghijklmnopqrstuvwxyz{|}"
	}
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		toUpperCaseUnsafe(str)
	}
}

func BenchmarkToUpperCaseByte(b *testing.B) {
	str := "@ABCDEFGHIJKLMNOPQRSTUVWXYZ_`abcdefghijklmnopqrstuvwxyz{|}"
	for i := 0; i < 1000; i++ {
		str += "@ABCDEFGHIJKLMNOPQRSTUVWXYZ_`abcdefghijklmnopqrstuvwxyz{|}"
	}
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		toUpperCaseByte(str)
	}
}
```

结果是按32位处理的每次59550ns，字节处理每次52542ns，还要慢。其中为了提高性能使用了unsafe包将byte数组强制转换成了int数组，也只能是这样的结果。

应该还可以优化，或者如果是64位处理呢？
